# syntax=docker/dockerfile:1.7

# Cross-Platform Build Support:
# - For x86-64 (current): docker build --platform linux/amd64 ...
# - For ARM64: docker build --platform linux/arm64 ...
# Platform is specified via GitHub Actions buildx configuration

# ============================================================================
# Stage 1: Import UV binary from official image
# ============================================================================
FROM ghcr.io/astral-sh/uv:0.9.26 AS uv

# ============================================================================
# Stage 2: Builder stage - Install dependencies
# ============================================================================
FROM public.ecr.aws/lambda/python:3.12 AS builder

# UV environment variables for optimal performance
# - UV_COMPILE_BYTECODE=1: Precompile bytecode (faster cold starts)
# - UV_NO_INSTALLER_METADATA=1: Deterministic layers (smaller image)
# - UV_LINK_MODE=copy: Cache mount compatibility
ENV UV_COMPILE_BYTECODE=1 \
    UV_NO_INSTALLER_METADATA=1 \
    UV_LINK_MODE=copy

# Install system dependencies
# Note: tesseract removed for Lambda - OCR can be added via Lambda layers
# To add tesseract:
#   1. Use pre-built layer (recommended): See LAMBDA_LAYERS.md
#   2. Build custom layer: Run ./build-tesseract-layer.sh
#   3. Add layer ARN to Lambda function configuration
RUN dnf install -y \
    poppler-utils \
    gcc \
    gcc-c++ \
    && dnf clean all

# Copy requirements.txt FIRST (layer caching optimization)
# This ensures package installations are cached separately from code changes
COPY requirements.txt .

# Install Python dependencies with UV + BuildKit cache mount
# - UV is 10-100x faster than pip for large dependency sets
# - Cache mount preserves downloads across builds (5-day retention in GitHub Actions)
# - Packages install to LAMBDA_TASK_ROOT for Lambda compatibility
RUN --mount=from=uv,source=/uv,target=/bin/uv \
    --mount=type=cache,target=/root/.cache/uv \
    uv pip install -r requirements.txt --target "${LAMBDA_TASK_ROOT}" --index-strategy unsafe-best-match

# Copy application code AFTER dependencies
# This ensures code changes don't invalidate the package cache layer
COPY app/ ${LAMBDA_TASK_ROOT}/app/
COPY lambda_handler.py ${LAMBDA_TASK_ROOT}/

# Fix file permissions for Lambda runtime (do this in builder stage where find is available)
RUN chmod -R 755 ${LAMBDA_TASK_ROOT}/app && \
    chmod 644 ${LAMBDA_TASK_ROOT}/lambda_handler.py && \
    find ${LAMBDA_TASK_ROOT}/app -type f -name "*.py" -exec chmod 644 {} \;

# ============================================================================
# Stage 3: Final minimal runtime image
# ============================================================================
# Use pre-built base image with all system dependencies installed
# This saves 20-25 minutes per deployment by eliminating dnf install
#
# Base image includes:
# - PDF processing: poppler, poppler-utils, poppler-glib
# - Rendering: cairo, pango, freetype, harfbuzz, fontconfig
# - OpenGL: mesa-libGL, mesa-libGLU, mesa-libgbm, libglvnd-*
# - X11: libX11, libXext, libXrender, libxcb, libXau, etc.
# - Image formats: libpng, libjpeg-turbo, libtiff, openjpeg2
# - Build tools: gcc, gcc-c++
# - System utilities: file-libs, glib2
#
# To rebuild base image (only when system deps change):
#   ./build-base-image.sh
#
FROM 803443341114.dkr.ecr.us-east-1.amazonaws.com/lambda-python-deps:3.12

# Copy everything from builder stage (permissions already fixed)
COPY --from=builder ${LAMBDA_TASK_ROOT} ${LAMBDA_TASK_ROOT}

# Set Lambda handler
CMD ["lambda_handler.handler"]
