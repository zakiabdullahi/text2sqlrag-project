name: Deploy to AWS Lambda

on:
  push:
    branches: [main]

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: rag-text-to-sql
  LAMBDA_FUNCTION: rag-text-to-sql-server

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Print deployment info
        run: |
          echo "=========================================="
          echo "üöÄ AWS Lambda Deployment Started"
          echo "=========================================="
          echo "Trigger: Push to main branch"
          echo "Commit: ${{ github.sha }}"
          echo "Author: ${{ github.actor }}"
          echo "Repository: ${{ github.repository }}"
          echo "Workflow: ${{ github.workflow }}"
          echo "Run Number: ${{ github.run_number }}"
          echo ""
          echo "üìã Deployment Configuration:"
          echo "   ‚Ä¢ AWS Region: ${{ env.AWS_REGION }}"
          echo "   ‚Ä¢ ECR Repository: ${{ env.ECR_REPOSITORY }}"
          echo "   ‚Ä¢ Lambda Function: ${{ env.LAMBDA_FUNCTION }}"
          echo "   ‚Ä¢ Platform: linux/amd64"
          echo ""
          echo "‚è±Ô∏è  Estimated deployment time: 2-8 minutes (cached: ~2 min, first build: ~5-8 min)"
          echo "=========================================="
          echo ""

      - name: Set up Docker
        run: |
          echo "üîß Verifying Docker installation..."
          docker version
          echo "‚úÖ Docker ready!"
          echo ""

      - name: Configure AWS credentials
        run: |
          echo "üîê Configuring AWS credentials..."
      - name: Debug AWS Secrets
        run: |
          if [ -z "${{ secrets.AWS_ACCESS_KEY_ID }}" ]; then
            echo "AWS_ACCESS_KEY_ID is EMPTY"
          else
            echo "AWS_ACCESS_KEY_ID is SET"
          fi

          if [ -z "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]; then
            echo "AWS_SECRET_ACCESS_KEY is EMPTY"
          else
            echo "AWS_SECRET_ACCESS_KEY is SET"
          fi
      - name: Configure AWS credentials (action)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify AWS credentials
        run: |
          echo "‚úÖ AWS credentials configured!"
          echo "Region: ${{ env.AWS_REGION }}"
          aws sts get-caller-identity
          echo ""

      - name: Login to Amazon ECR
        run: |
          echo "üîê Logging into Amazon ECR..."

      - name: Login to Amazon ECR (action)
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Verify ECR login
        run: |
          echo "‚úÖ Successfully logged into ECR!"
          echo "Registry: ${{ steps.login-ecr.outputs.registry }}"
          echo ""

      # - name: Pull base image
      #   run: |
      #     echo "üì• Pulling Lambda base image..."
      #     echo "   Image: ${{ steps.login-ecr.outputs.registry }}/lambda-python-deps:3.12"
      #     docker pull ${{ steps.login-ecr.outputs.registry }}/lambda-python-deps:3.12
      #     echo "‚úÖ Base image pulled successfully"
      #     echo ""
      - name: Free Disk Space
        run: |
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /usr/local/lib/android
          sudo rm -rf /opt/ghc
          docker system prune -af
      - name: Build Docker image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "üî® Building Docker image..."
          echo "   Platform: linux/amd64"
          echo "   Image: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          echo ""

          docker build \
            --platform linux/amd64 \
            -f Dockerfile.lambda \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:latest \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:amd64 \
            .

          echo "‚úÖ Build complete!"
          echo ""

      - name: Push images to ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "üì§ Pushing images to ECR..."
          echo "   Pushing 3 tags: $IMAGE_TAG, latest, amd64"
          echo ""

          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:amd64

          echo "‚úÖ All images pushed successfully!"
          echo ""

      - name: Print build summary
        run: |
          echo "=========================================="
          echo "‚úÖ All images pushed to ECR successfully!"
          echo "=========================================="
          echo "Image URI: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ github.sha }}"
          echo "Tags: ${{ github.sha }}, latest, amd64"
          echo "Platform: linux/amd64"
          echo ""
      - name: Deploy Lambda function
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          IMAGE_URI="$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
      
          echo ""
          echo "=========================================="
          echo "üöÄ Deploying Lambda Function"
          echo "=========================================="
          echo "Function Name: ${{ env.LAMBDA_FUNCTION }}"
          echo "Image URI: $IMAGE_URI"
          echo "Architecture: x86-64"
          echo "Region: ${{ env.AWS_REGION }}"
          echo ""
      
          # Check if function exists
          if aws lambda get-function \
            --function-name ${{ env.LAMBDA_FUNCTION }} \
            > /dev/null 2>&1; then
      
            echo "üîÑ Function exists. Updating..."
            
            aws lambda update-function-code \
              --function-name ${{ env.LAMBDA_FUNCTION }} \
              --image-uri $IMAGE_URI \
              --architectures x86_64
      
            echo "‚è≥ Waiting for update..."
            aws lambda wait function-updated \
              --function-name ${{ env.LAMBDA_FUNCTION }}
      
          else
            echo "üÜï Function does not exist. Creating..."
      
            aws lambda create-function \
              --function-name ${{ env.LAMBDA_FUNCTION }} \
              --package-type Image \
              --code ImageUri=$IMAGE_URI \
              --role arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/rag-lambda-execution-role \
              --architectures x86_64 \
              --timeout 900 \
              --memory-size 3008 \
              --ephemeral-storage Size=10240 \
              --description "Multi-Source RAG + Text-to-SQL API"
      
            echo "‚è≥ Waiting for creation..."
            aws lambda wait function-active \
              --function-name ${{ env.LAMBDA_FUNCTION }}
          fi
      
          echo ""
          echo "üìä Lambda Function Status:"
          aws lambda get-function \
            --function-name ${{ env.LAMBDA_FUNCTION }} \
            --query '{State:Configuration.State,LastUpdateStatus:Configuration.LastUpdateStatus,Architecture:Configuration.Architectures[0],Memory:Configuration.MemorySize,Timeout:Configuration.Timeout}' \
            --output table
      
          echo ""
          echo "=========================================="
          echo "‚úÖ Lambda deployment completed!"
          echo "=========================================="

      # - name: Update Lambda function
      #   env:
      #     ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      #     IMAGE_TAG: ${{ github.sha }}
      #   run: |
      #     echo ""
      #     echo "=========================================="
      #     echo "üöÄ Updating Lambda Function"
      #     echo "=========================================="
      #     echo "Function Name: ${{ env.LAMBDA_FUNCTION }}"
      #     echo "Image URI: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
      #     echo "Architecture: x86-64"
      #     echo "Region: ${{ env.AWS_REGION }}"
      #     echo ""

      #     # Update Lambda function code with ARM64 architecture
      #     # IMPORTANT: --architectures flag MUST be used with update-function-code
      #     echo "üìù Updating Lambda function code..."
      #     aws lambda update-function-code \
      #       --function-name ${{ env.LAMBDA_FUNCTION }} \
      #       --image-uri $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
      #       --architectures x86_64
      #     echo "‚úÖ Update command sent!"
      #     echo ""

      #     # Wait for update to complete
      #     echo "‚è≥ Waiting for Lambda function to finish updating..."
      #     echo "   This may take 30-60 seconds..."
      #     aws lambda wait function-updated \
      #       --function-name ${{ env.LAMBDA_FUNCTION }}
      #     echo "‚úÖ Lambda function updated successfully!"
      #     echo ""

      #     # Get function info
      #     echo "üìä Lambda Function Status:"
      #     aws lambda get-function \
      #       --function-name ${{ env.LAMBDA_FUNCTION }} \
      #       --query '{State:Configuration.State,LastUpdateStatus:Configuration.LastUpdateStatus,Architecture:Configuration.Architectures[0],Memory:Configuration.MemorySize,Timeout:Configuration.Timeout}' \
      #       --output table
      #     echo ""

      #     echo "=========================================="
      #     echo "‚úÖ Lambda deployment completed!"
      #     echo "=========================================="

      - name: Configure Lambda Environment (S3 Storage + Redis Cache)
        run: |
          echo ""
          echo "=========================================="
          echo "‚öôÔ∏è  Configuring Lambda Environment Variables"
          echo "=========================================="
          echo "Function Name: ${{ env.LAMBDA_FUNCTION }}"
          echo "Storage Backend: S3"
          echo "S3 Bucket: ${{ secrets.S3_CACHE_BUCKET }}"
          echo "Query Cache: Upstash Redis"
          echo "AWS Region: ${{ env.AWS_REGION }}"
          echo ""

          # Fetch and merge environment variables
          echo "üì• Fetching current environment variables..."
          aws lambda get-function-configuration \
            --function-name ${{ env.LAMBDA_FUNCTION }} \
            --query 'Environment.Variables' \
            --output json > /tmp/current-vars.json

          echo "üîß Merging S3 storage and Redis cache configuration..."
          jq '. + {
            "STORAGE_BACKEND": "s3",
            "S3_CACHE_BUCKET": "${{ secrets.S3_CACHE_BUCKET }}",
            "PINECONE_API_KEY": "${{ secrets.PINECONE_API_KEY }}",
            "PINECONE_ENVIRONMENT": "${{ secrets.PINECONE_ENVIRONMENT }}",
            "PINECONE_INDEX_NAME": "${{ secrets.PINECONE_INDEX_NAME }}",
            "OPENAI_API_KEY": "${{ secrets.OPENAI_API_KEY }}",
            "DATABASE_URL": "${{ secrets.DATABASE_URL }}",
            "UPSTASH_REDIS_URL": "${{ secrets.UPSTASH_REDIS_URL }}",
            "UPSTASH_REDIS_TOKEN": "${{ secrets.UPSTASH_REDIS_TOKEN }}",
            "ENVIRONMENT": "production",
            "HOME": "/tmp",
            "TMPDIR": "/tmp",
            "TEMP": "/tmp",
            "TMP": "/tmp",
            "HF_HOME": "/tmp/.cache/huggingface",
            "TRANSFORMERS_CACHE": "/tmp/.cache/huggingface",
            "UNSTRUCTURED_CACHE_DIR": "/tmp/.cache/unstructured",
            "DOCLING_CACHE_DIR": "/tmp/.cache/docling",
            "USE_DOCKLING": "false"
          }' /tmp/current-vars.json | jq '{Variables: .}' > /tmp/env-config.json

          echo "üìã Environment configuration to apply:"
          cat /tmp/env-config.json | jq .

          echo ""
          echo "üì§ Updating Lambda environment variables..."
          aws lambda update-function-configuration \
            --function-name ${{ env.LAMBDA_FUNCTION }} \
            --environment file:///tmp/env-config.json

          echo "‚úÖ Environment variables updated"
          echo ""

          # Wait for update to complete
          echo "‚è≥ Waiting for configuration update to complete..."
          aws lambda wait function-updated \
            --function-name ${{ env.LAMBDA_FUNCTION }}
          echo "‚úÖ Configuration update complete"
          echo ""

          # Verify configuration
          echo "üîç Verifying S3 storage configuration..."
          STORAGE_BACKEND=$(aws lambda get-function-configuration \
            --function-name ${{ env.LAMBDA_FUNCTION }} \
            --query 'Environment.Variables.STORAGE_BACKEND' \
            --output text)

          S3_BUCKET=$(aws lambda get-function-configuration \
            --function-name ${{ env.LAMBDA_FUNCTION }} \
            --query 'Environment.Variables.S3_CACHE_BUCKET' \
            --output text)

          echo "   Storage Backend: $STORAGE_BACKEND"
          echo "   S3 Bucket: $S3_BUCKET"
          echo ""

          if [ "$STORAGE_BACKEND" = "s3" ] && [ "$S3_BUCKET" = "${{ secrets.S3_CACHE_BUCKET }}" ]; then
            echo "=========================================="
            echo "‚úÖ S3 Storage Configuration Verified!"
            echo "=========================================="
          else
            echo "=========================================="
            echo "‚ùå Configuration Verification Failed"
            echo "=========================================="
            echo "Expected Storage Backend: s3"
            echo "Actual Storage Backend: $STORAGE_BACKEND"
            echo ""
            echo "Expected S3 Bucket: ${{ secrets.S3_CACHE_BUCKET }}"
            echo "Actual S3 Bucket: $S3_BUCKET"
            exit 1
          fi

      - name: Test deployment
        env:
          API_URL: ${{ secrets.API_GATEWAY_URL }}
        run: |
          echo ""
          echo "=========================================="
          echo "üß™ Testing Lambda Deployment"
          echo "=========================================="
          echo "API Gateway URL: $API_URL"
          echo "Testing: /health and /info endpoints"
          echo ""

          echo "‚è≥ Waiting 10 seconds for Lambda cold start..."
          echo "   (Lambda needs time to initialize services on first invocation)"
          for i in {10..1}; do
            echo -n "   $i seconds remaining..."
            sleep 1
            echo -ne "\r"
          done
          echo "   ‚úÖ Wait complete!"
          echo ""

          # Test health endpoint with retries (Lambda cold start can take time)
          echo "üè• Testing health endpoint with retry logic..."
          echo "   Endpoint: $API_URL/health"
          RETRY=0
          MAX_RETRIES=3
          until curl -f -s "$API_URL/health" > /dev/null || [ $RETRY -eq $MAX_RETRIES ]; do
            RETRY=$((RETRY+1))
            echo "   ‚ö†Ô∏è  Attempt $RETRY/$MAX_RETRIES failed, waiting 5 seconds before retry..."
            sleep 5
          done

          if [ $RETRY -eq $MAX_RETRIES ]; then
            echo ""
            echo "=========================================="
            echo "‚ùå DEPLOYMENT TEST FAILED"
            echo "=========================================="
            echo "Health endpoint still returning errors after $MAX_RETRIES attempts"
            echo ""
            echo "üîç Debugging Information:"
            echo "---"
            echo "Full URL: $API_URL/health"
            echo ""
            echo "üì° Verbose curl output:"
            curl -v "$API_URL/health" || true
            echo ""
            echo "üí° Troubleshooting steps:"
            echo "1. Check CloudWatch logs: aws logs tail /aws/lambda/rag-text-to-sql --follow"
            echo "2. Verify API Gateway URL includes /prod: $API_URL"
            echo "3. Check Lambda function status in AWS Console"
            echo "4. Verify environment variables are set in Lambda"
            echo ""
            exit 1
          fi

          echo "   ‚úÖ Health endpoint responding!"
          echo ""
          echo "üìã Health Check Response:"
          echo "---"
          curl -s "$API_URL/health" | head -20
          echo "---"
          echo ""

          # Test info endpoint
          echo "‚ÑπÔ∏è  Testing info endpoint..."
          echo "   Endpoint: $API_URL/info"
          if curl -f -s "$API_URL/info" > /dev/null; then
            echo "   ‚úÖ Info endpoint responding!"
            echo ""
            echo "üìã Info Response:"
            echo "---"
            curl -s "$API_URL/info"
            echo ""
            echo "---"
          else
            echo "   ‚ö†Ô∏è  Info endpoint failed (non-critical, continuing...)"
          fi

          echo ""
          echo "=========================================="
          echo "‚úÖ DEPLOYMENT TEST PASSED!"
          echo "=========================================="
          echo "üéâ Your Lambda function is live and responding!"
          echo ""
          echo "üìä Deployment Summary:"
          echo "   ‚Ä¢ Docker Image: Built for x86-64 (AMD64)"
          echo "   ‚Ä¢ Lambda: Updated successfully"
          echo "   ‚Ä¢ Health Check: ‚úÖ Passing"
          echo "   ‚Ä¢ Info Endpoint: ‚úÖ Passing"
          echo ""
          echo "üîó Your API is ready at: $API_URL"
          echo "=========================================="

      - name: Test S3 Storage Backend
        if: contains(github.event.head_commit.message, '[test-s3]') || github.event_name == 'release'
        env:
          API_URL: ${{ secrets.API_GATEWAY_URL }}
        run: |
          echo ""
          echo "=========================================="
          echo "ü™£ Testing S3 Storage Backend"
          echo "=========================================="
          echo "API Gateway URL: $API_URL"
          echo "S3 Bucket: ${{ secrets.S3_CACHE_BUCKET }}"
          echo ""

          # Create a test document
          echo "üìÑ Creating test document..."
          echo "This is a test document for S3 storage validation." > test-s3-storage.txt
          echo "The document cache should store this in S3." >> test-s3-storage.txt
          echo "Deployment timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> test-s3-storage.txt
          echo "Commit SHA: ${{ github.sha }}" >> test-s3-storage.txt
          echo "‚úÖ Test document created"
          echo ""

          # Force Lambda to cycle through containers by invoking multiple times
          # This ensures old warm containers (with old env vars) are replaced by new ones
          echo "üîÑ Forcing Lambda container refresh (cycling through warm containers)..."
          echo "   (Invoking 5 times to ensure all old containers are replaced)"
          SUCCESS_COUNT=0
          for i in {1..5}; do
            if [ $((i % 2)) -eq 0 ]; then
              echo "   Invocation $i/5..."
            fi
            if curl -f -s "$API_URL/health" > /dev/null 2>&1; then
              SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
            fi
            sleep 0.3  # Small delay between invocations
          done
          echo "   ‚úÖ Container refresh complete! ($SUCCESS_COUNT/5 invocations successful)"
          echo "   All new containers should now have STORAGE_BACKEND=s3"
          echo ""

          # Test 1: Initial upload (should NOT be cached)
          echo "üì§ Test 1: Initial document upload (expect cache_hit=false)..."
          UPLOAD1_RESPONSE=$(curl -s -X POST "$API_URL/upload" \
            -F "file=@test-s3-storage.txt" \
            -w "\nHTTP_STATUS:%{http_code}")

          HTTP_STATUS1=$(echo "$UPLOAD1_RESPONSE" | grep "HTTP_STATUS" | cut -d: -f2)
          UPLOAD1_JSON=$(echo "$UPLOAD1_RESPONSE" | grep -v "HTTP_STATUS")

          echo "   HTTP Status: $HTTP_STATUS1"

          if [ "$HTTP_STATUS1" != "200" ] && [ "$HTTP_STATUS1" != "201" ]; then
            echo "   ‚ùå Upload failed with status $HTTP_STATUS1"
            echo ""
            echo "üìã Response:"
            echo "$UPLOAD1_JSON"
            echo ""
            echo "üìã Fetching Lambda CloudWatch logs for debugging..."
            aws logs tail /aws/lambda/rag-text-to-sql --since 5m --format short || echo "‚ö†Ô∏è Could not fetch logs"
            exit 1
          fi

          echo "   ‚úÖ Upload successful"
          echo ""
          echo "üìã Upload Response:"
          echo "$UPLOAD1_JSON" | jq '.'
          echo ""

          # Verify storage backend is S3
          STORAGE_BACKEND1=$(echo "$UPLOAD1_JSON" | jq -r '.storage_backend // "unknown"')
          CACHE_HIT1=$(echo "$UPLOAD1_JSON" | jq -r '.cache_hit // false')
          DOC_ID=$(echo "$UPLOAD1_JSON" | jq -r '.document_id // "unknown"')

          echo "üîç Verification:"
          echo "   Storage Backend: $STORAGE_BACKEND1"
          echo "   Cache Hit: $CACHE_HIT1"
          echo "   Document ID: $DOC_ID"
          echo ""

          if [ "$STORAGE_BACKEND1" != "s3" ]; then
            echo "‚ùå STORAGE BACKEND TEST FAILED"
            echo "   Expected: s3"
            echo "   Actual: $STORAGE_BACKEND1"
            echo ""
            echo "üí° This means Lambda is not using S3 storage!"
            echo "   Check STORAGE_BACKEND environment variable in Lambda"
            exit 1
          fi

          if [ "$CACHE_HIT1" = "true" ]; then
            echo "‚ö†Ô∏è  Unexpected cache hit on first upload (non-critical)"
            echo "   This could mean the document was uploaded before"
          fi

          echo "‚úÖ Test 1 passed: S3 storage backend confirmed"
          echo ""

          # Test 2: Re-upload same document (should be cached in S3)
          # Note: S3 has strong read-after-write consistency - no wait needed
          echo "üì§ Test 2: Re-upload same document (expect cache_hit=true)..."
          UPLOAD2_RESPONSE=$(curl -s -X POST "$API_URL/upload" \
            -F "file=@test-s3-storage.txt" \
            -w "\nHTTP_STATUS:%{http_code}")

          HTTP_STATUS2=$(echo "$UPLOAD2_RESPONSE" | grep "HTTP_STATUS" | cut -d: -f2)
          UPLOAD2_JSON=$(echo "$UPLOAD2_RESPONSE" | grep -v "HTTP_STATUS")

          echo "   HTTP Status: $HTTP_STATUS2"

          if [ "$HTTP_STATUS2" != "200" ] && [ "$HTTP_STATUS2" != "201" ]; then
            echo "   ‚ùå Re-upload failed with status $HTTP_STATUS2"
            echo ""
            echo "üìã Response:"
            echo "$UPLOAD2_JSON"
            exit 1
          fi

          echo "   ‚úÖ Re-upload successful"
          echo ""
          echo "üìã Re-upload Response:"
          echo "$UPLOAD2_JSON" | jq '.'
          echo ""

          # Verify cache hit from S3
          STORAGE_BACKEND2=$(echo "$UPLOAD2_JSON" | jq -r '.storage_backend // "unknown"')
          CACHE_HIT2=$(echo "$UPLOAD2_JSON" | jq -r '.cache_hit // false')
          DOC_ID2=$(echo "$UPLOAD2_JSON" | jq -r '.document_id // "unknown"')

          echo "üîç Verification:"
          echo "   Storage Backend: $STORAGE_BACKEND2"
          echo "   Cache Hit: $CACHE_HIT2"
          echo "   Document ID: $DOC_ID2"
          echo "   IDs Match: $([ "$DOC_ID" = "$DOC_ID2" ] && echo "‚úÖ Yes" || echo "‚ùå No")"
          echo ""

          if [ "$STORAGE_BACKEND2" != "s3" ]; then
            echo "‚ùå STORAGE BACKEND TEST FAILED"
            echo "   Expected: s3"
            echo "   Actual: $STORAGE_BACKEND2"
            exit 1
          fi

          if [ "$CACHE_HIT2" != "true" ]; then
            echo "‚ùå S3 CACHE TEST FAILED"
            echo "   Expected cache_hit: true"
            echo "   Actual cache_hit: $CACHE_HIT2"
            echo ""
            echo "üí° This means S3 caching is not working correctly!"
            echo "   Possible issues:"
            echo "   - S3 bucket permissions not set"
            echo "   - S3 write succeeded but read failed"
            echo "   - Hash calculation inconsistency"
            exit 1
          fi

          if [ "$DOC_ID" != "$DOC_ID2" ]; then
            echo "‚ùå DOCUMENT ID MISMATCH"
            echo "   First upload: $DOC_ID"
            echo "   Second upload: $DOC_ID2"
            echo ""
            echo "üí° Document IDs should match for identical content!"
            exit 1
          fi

          echo "‚úÖ Test 2 passed: S3 cache hit confirmed"
          echo ""

          # Test 3: Verify S3 bucket contents
          echo "ü™£ Test 3: Verify S3 bucket contents..."
          echo "   Bucket: ${{ secrets.S3_CACHE_BUCKET }}"
          echo ""

          # List files for this document in S3
          echo "üìÇ Files in S3 for document $DOC_ID:"
          aws s3 ls "s3://${{ secrets.S3_CACHE_BUCKET }}/txt/$DOC_ID/" --recursive || {
            echo "‚ö†Ô∏è  Could not list S3 bucket contents (non-critical)"
            echo "   This may be due to IAM permissions for listing"
          }
          echo ""

          # Cleanup test file
          echo "üßπ Cleaning up test document..."
          rm -f test-s3-storage.txt
          echo "‚úÖ Cleanup complete"
          echo ""

          echo "=========================================="
          echo "‚úÖ S3 STORAGE TESTS PASSED!"
          echo "=========================================="
          echo "üéâ S3 storage backend is working correctly!"
          echo ""
          echo "üìä Test Summary:"
          echo "   ‚úÖ S3 storage backend detected"
          echo "   ‚úÖ Initial upload stored to S3"
          echo "   ‚úÖ S3 cache hit on re-upload"
          echo "   ‚úÖ Document ID consistency verified"
          echo ""
          echo "üîó S3 Bucket: s3://${{ secrets.S3_CACHE_BUCKET }}"
          echo "=========================================="
